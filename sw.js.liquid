---
permalink: /sw.js
eleventyExcludeFromCollections: true
---

const CACHE_NAME = 'vgb-site-cache-{{ cache-version }}';
const FONT_CACHE = 'google-fonts-v1';
const IMAGE_CACHE = 'images-v1';

const CORE_ASSETS = [
  '/',
  '/styles.css',
  '/assets/js/core.js',
  '/offline/',
];

const PRECACHE_IMAGES = [
  '/assets/images/favicon.svg',
  '/assets/images/icons.svg',
];

const CACHE_CATEGORIES = [
  '/basics/',
  '/gospel/',
  '/prophecy/',
];

const isLocalhost = self.location.hostname === 'localhost' || 
                    self.location.hostname === '127.0.0.1';

if (!isLocalhost) {
  self.addEventListener('install', event => {
    event.waitUntil(
      caches.open(CACHE_NAME)
        .then(cache => cache.addAll(CORE_ASSETS))
        .then(() => {
          // precache images
          return caches.open(IMAGE_CACHE)
            .then(cache => cache.addAll(PRECACHE_IMAGES))
            .catch(() => {});
        })
        .then(() => {
          // precache categories
          return caches.open(CACHE_NAME)
            .then(cache => cache.addAll(CACHE_CATEGORIES))
            .catch(() => {});
        })
        .then(() => self.skipWaiting()) // activate new SW immediately
    );
  });

  self.addEventListener('activate', event => {
    event.waitUntil(
      caches.keys().then(keys => 
        Promise.all(keys
          .filter(key => 
            key !== CACHE_NAME && 
            key !== FONT_CACHE && 
            key !== IMAGE_CACHE)
          .map(key => caches.delete(key)))
      )
      .then(() => self.clients.claim()) // take control of all open tabs immediately
    );
  });

  self.addEventListener('fetch', event => {
    const { request } = event;
    const url = new URL(request.url);

    if (request.method !== 'GET') return;

    // only cache same-origin requests (except Google Fonts)
    const isFont = url.origin === 'https://fonts.googleapis.com' || 
               url.origin === 'https://fonts.gstatic.com';
    const isSameOrigin = url.origin === self.location.origin;
    
    if (!isFont && !isSameOrigin) return;

    // Google Fonts: cache CSS and font files
    if (isFont) {
      event.respondWith(
        caches.open(FONT_CACHE).then(cache =>
          cache.match(request).then(cached => {
            if (cached) return cached;
            
            return fetch(request, { mode: 'cors' })
              .then(response => {
                if (response?.ok) {
                  cache.put(request, response.clone());
                }
                return response;
              });
          })
        )
      );
      return;
    }

    // Images: cache-first with separate cache
    if (request.destination === 'image') {
      event.respondWith(
        caches.open(IMAGE_CACHE).then(cache =>
          cache.match(request).then(cached => {
            if (cached) return cached;
            
            return fetch(request).then(response => {
              if (response?.ok) {
                cache.put(request, response.clone());
              }
              return response;
            });
          })
        )
      );
      return;
    }

    // HTML navigation: network-first, fallback to offline page
    if (request.mode === 'navigate') {
      event.respondWith(
        fetch(request)
          .catch(() => caches.match('/offline/'))
      );
      return;
    }

    // CSS/JS: cache-first
    if (request.destination === 'style' || 
        request.destination === 'script') {
      event.respondWith(
        caches.match(request).then(cached => {
          if (cached) return cached;
          
          return fetch(request).then(response => {
            if (response?.ok) {
              caches.open(CACHE_NAME)
                .then(cache => cache.put(request, response.clone()));
            }
            return response;
          });
        })
      );
      return;
    }
  });
}