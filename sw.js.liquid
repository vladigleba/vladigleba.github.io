---
permalink: /sw.js
eleventyExcludeFromCollections: true
---

const CACHE_NAME = 'vgb-site-cache-{{ cache-version }}';
const FONT_CACHE = 'google-fonts-cache';
const ASSETS_TO_CACHE = [
  '/',
  '/styles.css',
  '/assets/js/core.js',
  // images
  '/assets/images/favicon.svg',
  '/assets/images/icons.svg',
  '/assets/images/social-default.png',
  // categories
  '/basics/',
  '/gospel/',
  '/prophecy/',
  '/offline/',
];

// disable service worker caching on localhost for development
const isLocalhost =
  self.location.hostname === 'localhost' ||
  self.location.hostname === '127.0.0.1';

if (!isLocalhost) {

  // install SW, cache assets for offline
  self.addEventListener('install', event => {
    event.waitUntil(
      caches.open(CACHE_NAME)
        .then(cache => cache.addAll(ASSETS_TO_CACHE))
        .then(() => self.skipWaiting()) // activate new SW AFTER cache is ready
    );
  });

  // activate SW, delete old caches
  self.addEventListener('activate', event => {
    event.waitUntil(
      caches.keys().then(keys =>
        Promise.all(
          keys
            .filter(key =>
              key !== CACHE_NAME &&
              key !== FONT_CACHE
            )
            .map(key => caches.delete(key))
        )
      ).then(() => self.clients.claim()) // take control of all open tabs immediately
    );
  });

  // fetch
  self.addEventListener('fetch', event => {
    const request = event.request;
    const url = request.url;

    // Google Fonts: cache-first
    if (
      url.startsWith('https://fonts.googleapis.com/') ||
      url.startsWith('https://fonts.gstatic.com/')
    ) {
      event.respondWith(
        caches.open(FONT_CACHE).then(cache =>
          cache.match(request).then(cached => {
            if (cached) return cached;

            return fetch(request).then(response => {
              if (response && response.status === 200) {
                cache.put(request, response.clone());
              }
              return response;
            });
          })
        )
      );
      return;
    }

    // HTML navigation: network first
    if (request.mode === 'navigate') {
      event.respondWith(
        fetch(request)
          .then(response => {
            const clone = response.clone();
            caches.open(CACHE_NAME).then(cache =>
              cache.put(request, clone)
            );
            return response;
          })
          .catch(() => caches.match('/offline/'))
      );
      return;
    }

    // everything else: cache first
    event.respondWith(
      caches.match(request).then(cached => {
        if (cached) return cached;

        // not in cache, fetch from network and cache it
        return fetch(request).then(response => {
          if (response && response.status === 200) {
            const clone = response.clone();
            caches.open(CACHE_NAME).then(cache =>
              cache.put(request, clone)
            );
          }
          return response;
        });
      })
    );
  });
}
