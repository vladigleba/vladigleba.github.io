<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Topic: Phindee | Vladi Gleba]]></title>
  <link href="http://vladigleba.github.io/blog/topics/phindee/atom.xml" rel="self"/>
  <link href="http://vladigleba.github.io/"/>
  <updated>2014-09-11T19:33:00-07:00</updated>
  <id>http://vladigleba.github.io/</id>
  <author>
    <name><![CDATA[Vladi Gleba]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Provisioning a Rails Server Using Chef, Part 3: Tying It All Together]]></title>
    <link href="http://vladigleba.github.io/blog/2014/09/02/provisioning-a-rails-server-using-chef-part-3-tying-it-all-together/"/>
    <updated>2014-09-02T14:02:00-07:00</updated>
    <id>http://vladigleba.github.io/blog/2014/09/02/provisioning-a-rails-server-using-chef-part-3-tying-it-all-together</id>
    <content type="html"><![CDATA[<p>We installed Chef Solo in <a href="/blog/2014/07/28/provisioning-a-rails-server-using-chef-part-1-introduction-to-chef-solo/">part 1</a>, we wrote some recipes in <a href="/blog/2014/08/12/provisioning-a-rails-server-using-chef-part-2-writing-the-recipes/">part 2</a>, and now we&rsquo;ll be tying everything together in part 3. When we&rsquo;re done, we&rsquo;ll not only have a fully provisioned server running your Rails app, but we&rsquo;ll also have an automated way of repeating this process whenever such a need arises in the future.</p>

<!-- more -->


<h1>Some Groundwork</h1>

<p>Before we can run the recipes from part 2, we need to specify exactly which recipes we want to run and in what order. Chef has something called a run list exactly for this purpose, and we store it in the JSON file located in the <code>/nodes</code> directory (I usually add it to the top of the file, before all the node-specific attributes, to make it easy to spot):</p>

<p>``` json 123.123.123.123.json
{
  &ldquo;run_list&rdquo;: [</p>

<pre><code>"recipe[phindee]",
"recipe[phindee::users]",
"recipe[phindee::ssh]",
"recipe[phindee::nodejs]",
"recipe[phindee::postgres]",
"recipe[phindee::rbenv]",
"recipe[phindee::redis]",
"recipe[phindee::nginx]",
"recipe[phindee::app]"
</code></pre>

<p>  ],</p>

<p>  &hellip;
}
```</p>

<p>Because Chef executes the run list in the exact order it&rsquo;s specified, it&rsquo;s important to list the recipes that other recipes will depend on first. Some of our recipes, for example, use the user that&rsquo;s created in <code>users.rb</code>, so that&rsquo;s why we place that recipe near the top, but recipes that don&rsquo;t depend on any other recipes can be placed anywhere you want. (Note that when referencing the <code>default.rb</code> recipe, it&rsquo;s enough to just specify the name of the cookbook it&rsquo;s located in, but in order to run the other recipes, it&rsquo;s necessary to specify the cookbook, along with the recipe&rsquo;s file name.)</p>

<p>By the way, if you ever find yourself not needing a particular recipe to run, all you need to do is remove that recipe from the run list, and Chef won&rsquo;t run it, but do be careful about removing recipes that other recipes depend on because that will cause issues.</p>

<h1>Show Time</h1>

<p>With our run list defined, we&rsquo;re now ready to start the provisioning process. Because we&rsquo;ll need to use quite a number of commands to get everything provisioned, it&rsquo;s best to automate this by creating a shell script. I created a file called <code>setup_vps.sh</code> inside my app&rsquo;s <code>/config</code> directory for this purpose:</p>

<p>``` bash setup_vps.sh</p>

<h1>!/bin/sh</h1>

<h1>check for correct number of arguments</h1>

<p>if [ $# -ne 3 ]; then
  echo &ldquo;Usage: $0 <user> <ip> <port>&rdquo;
  exit 1
fi</p>

<h1>set variables</h1>

<p>USER=$1
IP=$2
PORT=$3</p>

<h1>upload key for root</h1>

<p>ssh-copy-id -i ~/.ssh/id_rsa.pub root@$IP</p>

<h1>install chef</h1>

<p>cd config/chef &amp;&amp; knife solo prepare root@$IP</p>

<h1>execute the run list</h1>

<p>knife solo cook root@$IP</p>

<h1>upload key for user</h1>

<p>ssh-copy-id -i ~/.ssh/id_rsa.pub -p $PORT $USER@$IP</p>

<h1>upload app</h1>

<p>cd ../.. &amp;&amp; cap production setup:all</p>

<h1>restart nginx</h1>

<p>ssh -p $PORT -t $USER@$IP &lsquo;sudo service nginx restart&rsquo;
```</p>

<p>The first line uploads your public key to the node (server) you&rsquo;re about to provision. (If you don&rsquo;t do this, Chef Solo will ask you to type your password for every command it runs.) The next line installs Chef on our node using the <code>knife solo prepare</code> command, while the line after that uses <code>knife solo cook</code> to execute our run list. When it finishes, our node will be fully provisioned.</p>

<p>The remaining three lines run the Capistrano recipes to deploy my app (if you&rsquo;re not using Capistrano for deployment, feel free to remove them). The third to last line uploads the public key for the Chef-created user (so Capistrano can log in without a password), the next line runs the Capistrano recipes, and the last line restarts Nginx (so the uploaded Rails app is loaded in).</p>

<p>Once you run <code>chmod +x setup_vps.sh</code> to make the file an executable, you can <code>cd</code> into the directory containing the script and run it with</p>

<p><code>bash
./setup_vps.sh bob 123.123.123.123 12345
</code>
where <code>bob</code> is the Chef-created user, <code>123.123.123.123</code> is the IP address of the node you just provisioned, and <code>12345</code> is its port. When the script finishes executing, you&rsquo;ll have a fully provisioned server running your Rails app.</p>

<h1>Capistrano Code</h1>

<p>In the interest of completeness, here&rsquo;s the Capistrano code I use to deploy my app. First up is my <code>setup.rake</code> file containing the <code>all</code> task that I&rsquo;m referencing in <code>setup_vps.sh</code>:</p>

<p>``` ruby setup.rake
namespace :setup do</p>

<p>  desc &ldquo;Runs all tasks.&rdquo;
  task all: [:deploy, :seed_postgres, :seed_redis]</p>

<p>  desc &ldquo;Seed the main database.&rdquo;
  task :seed_postgres do</p>

<pre><code>on roles(:app) do
  within "#{current_path}" do
    with rails_env: :production do
      execute :rake, "db:seed"
    end
  end
end
</code></pre>

<p>  end</p>

<p>  desc &lsquo;Seed the redis database (search suggestions)&rsquo;
  task :seed_redis do</p>

<pre><code>on roles(:app) do
  within "#{current_path}" do
    with rails_env: :production do
      execute :rake, "search_suggestions:index"
    end
  end
end
</code></pre>

<p>  end</p>

<p>  after &ldquo;deploy:published&rdquo;, &ldquo;deploy:start&rdquo;</p>

<p>end
```</p>

<p>And here&rsquo;s my <code>deploy.rake</code> file containing the <code>start</code> task that I&rsquo;m calling in <code>setup.rake</code>:</p>

<p>``` ruby deploy.rake
namespace :deploy do</p>

<p>  desc &ldquo;Makes sure local git is in sync with remote.&rdquo;
  task :check_revision do</p>

<pre><code>unless `git rev-parse HEAD` == `git rev-parse origin/master`
  puts "WARNING: HEAD is not the same as origin/master"
  puts "Run `git push` to sync changes."
  exit
end
</code></pre>

<p>  end</p>

<p>  %w[start stop restart].each do |command|</p>

<pre><code>desc "#{command} Unicorn server."
task command do
  on roles(:app) do
    execute "/etc/init.d/unicorn_#{fetch(:application)} #{command}"
  end
end
</code></pre>

<p>  end</p>

<p>  before :deploy, &ldquo;deploy:check_revision"<br/>
  after :deploy, "deploy:restart&rdquo;
  after :rollback, &ldquo;deploy:restart&rdquo;</p>

<p>end
```</p>

<p>Below are my <code>deploy.rb</code> and <code>production.rb</code> files:</p>

<p>``` ruby deploy.rb
lock &lsquo;3.2.1&rsquo;</p>

<p>set :application, &lsquo;phindee&rsquo;
set :repo_url, &lsquo;git@github.com:vladigleba/phindee.git&rsquo;</p>

<p>set :deploy_to, &ldquo;/var/www/#{fetch(:application}&rdquo;
set :deploy_user, &ldquo;bob&rdquo;</p>

<p>set :rbenv_type, :user
set :rbenv_ruby, &lsquo;2.1.0&rsquo;
set :rbenv_prefix, &ldquo;RBENV_ROOT=#{fetch(:rbenv_path)} RBENV_VERSION=#{fetch(:rbenv_ruby)} #{fetch(:rbenv_path)}/bin/rbenv exec&rdquo;
set :rbenv_map_bins, %w{rake gem bundle ruby rails}
set :rbenv_roles, :all</p>

<p>set :linked_files, %w{config/database.yml config/application.yml}
set :linked_dirs, %w{bin log tmp/pids tmp/cache tmp/sockets vendor/bundle public/system}</p>

<p>set :keep_releases, 5
```</p>

<p>``` ruby production.rb
set :stage, :production
set :rails_env, :production</p>

<p>server &ldquo;#{fetch(:deploy_user)}@123.123.123.123:12345&rdquo;, roles: %w{web app db}, primary: true
```</p>

<p>I won&rsquo;t be explaining the Capistrano code because that&rsquo;s already covered in parts <a href="/blog/2014/04/04/deploying-rails-apps-part-5-configuring-capistrano/">5</a> and <a href="/blog/2014/04/10/deploying-rails-apps-part-6-writing-capistrano-tasks/">6</a> of my <a href="/blog/topics/deployment-series/">&ldquo;Deploying Rails Apps&rdquo; series</a>, so be sure to check that out if you&rsquo;re new to Capistrano or just need some clarification. (It&rsquo;s worth noting that Chef actually has a <a href="http://docs.getchef.com/chef/resources.html#deploy"><code>deploy</code></a> resource that&rsquo;s modeled after Capistrano, but I didn&rsquo;t have time to learn how to implement my existing Capistrano recipes with it. If you&rsquo;re interested though, feel free to give it a try.)</p>

<p>I hope this gave you a taste of what Chef can do, although I only scratched the service of what&rsquo;s possible. Chef is a complex tool that can be used to manage entire server infrastructures, and although it might be overkill for managing a single server, it&rsquo;s still a useful tool to learn if you spend a significant amount of time doing server provisioning. It&rsquo;s definitely an improvement over shell scripts because it keeps your code readable and organized. Ultimately though, each tool has its place, and it&rsquo;s up to you to decide what best fits your particular need.</p>

<p>Stay hungry. Stay foolish.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Provisioning a Rails Server Using Chef, Part 2: Writing the Recipes]]></title>
    <link href="http://vladigleba.github.io/blog/2014/08/12/provisioning-a-rails-server-using-chef-part-2-writing-the-recipes/"/>
    <updated>2014-08-12T09:29:00-07:00</updated>
    <id>http://vladigleba.github.io/blog/2014/08/12/provisioning-a-rails-server-using-chef-part-2-writing-the-recipes</id>
    <content type="html"><![CDATA[<p>In <a href="/blog/2014/07/28/provisioning-a-rails-server-using-chef-part-1-introduction-to-chef-solo/">part 1</a>, we learned about Chef Solo and used it to create a standard Chef directory structure, along with our own cookbook. Now it&rsquo;s time to start writing the recipes we will run to provision our Rails server and install Node.js, PostgreSQL, rbenv, Ruby, Redis, and Nginx.</p>

<!-- more -->


<h1>Defining Default Values</h1>

<p>The first thing we&rsquo;ll do is define some default values for our recipes. Go ahead and create a new file called <code>default.rb</code> inside the <code>/attributes</code> directory of the cookbook you created in part 1, and add the following code into it:</p>

<p>``` ruby default.rb
default[&lsquo;app&rsquo;]               = &lsquo;phindee&rsquo;</p>

<p>default[&lsquo;nodejs&rsquo;][&lsquo;dir&rsquo;]     = &lsquo;/usr/local&rsquo;
default[&lsquo;nodejs&rsquo;][&lsquo;version&rsquo;] = &lsquo;0.10.29&rsquo;</p>

<p>default[&lsquo;ruby&rsquo;][&lsquo;version&rsquo;]   = &lsquo;2.1.2&rsquo;
default[&lsquo;redis&rsquo;][&lsquo;version&rsquo;]  = &lsquo;2.8.13&rsquo;
```</p>

<p>These are called attributes, and they&rsquo;re just variables that are later used in recipes. We&rsquo;re defining simple things here like the app name, the directory where Node.js will be installed, and the versions of the software we&rsquo;ll be installing. Storing such things in a single file makes it easy to modify them later on.</p>

<p>This file is great for storing attributes that will be shared with more than one server, but attributes that are server-specific, like ports, usernames, and passwords, will be stored in another JSON file outside our cookbook. If you followed part 1, your cookbook is stored in your app&rsquo;s <code>/config/chef/site-cookbooks</code> directory, but this JSON file will reside inside the <code>/config/chef/nodes</code> directory, and it&rsquo;ll be named after the IP address of the server you&rsquo;ll be provisioning (for example, <code>123.123.123.123.json</code>).</p>

<p>Go ahead and create the file now, and add the following code into it (be sure to replace the attributes with your own):</p>

<p>``` json 123.123.123.123.json
{
  &ldquo;group&rdquo;: &ldquo;foobars&rdquo;,
  &ldquo;port&rdquo;: 12345,</p>

<p>  &ldquo;user&rdquo;: {</p>

<pre><code>"name": "bob",
"password": "password-shadow-hash"
</code></pre>

<p>  },</p>

<p>  &ldquo;db&rdquo;: {</p>

<pre><code>"root_password": "secret",
"user": {
  "name": "bob",
  "password": "secret"
}
</code></pre>

<p>  }
}
```</p>

<p>Due to the sensitive nature of this file, it&rsquo;s best to add it to your <code>.gitignore</code> file so it doesn&rsquo;t get uploaded to GitHub. Here&rsquo;s the line you&rsquo;ll need to add:</p>

<p><code>text .gitignore
/config/chef/nodes/123.123.123.123.json
</code></p>

<p>One thing I&rsquo;d like to point out is Chef doesn&rsquo;t use plain text passwords when creating new users. Instead, it uses a <a href="http://en.wikipedia.org/wiki/Passwd#Shadow_file">shadow hash</a> of the plain text password, so the <code>user.password</code> attribute must be a shadow hash. If you have the <code>openssl</code> command installed on your local computer, you can create a password shadow hash by running the following:</p>

<p><code>bash
openssl passwd -1 "theplaintextpassword"
</code></p>

<p>This just uses the <code>passwd</code> command provided by <code>openssl</code> to create an MD5-based hash of the password (specified by the <code>-1</code> flag). You can then copy and paste the string that the command returns into the JSON file above. Once the user is set up on our node, you&rsquo;ll still use the plain text password to log in, just like always. I wasn&rsquo;t able to get shadow hash passwords working with PostgreSQL though, which is why I&rsquo;m just using the plain text password there, but feel free to leave a comment if you know how to make it work.</p>

<p>One last thing I want to mention is that if you have the same attribute defined in both <code>default.rb</code> and the JSON file, the latter will always override the former.</p>

<h1>Writing Recipes</h1>

<p>Now that the attributes are defined, we&rsquo;re ready to start writing the recipes themselves. These recipes do the exact same server setup as the one covered in the <a href="/blog/topics/deployment-series/">&ldquo;Deploying Rails Apps&rdquo; series</a>, so I won&rsquo;t be explaining the whys behind the things I do here since that&rsquo;s already covered in the series itself. If you&rsquo;ve never provisioned a server from scratch before, it&rsquo;s best to read that series first before continuing.</p>

<h2>The First One</h2>

<p>Our first recipe will install various packages and set the correct time zone. Create a new file called <code>default.rb</code> inside the <code>/recipes</code> directory of your cookbook, and add the following code into it:</p>

<p>``` ruby default.rb</p>

<h1>update package database</h1>

<p>execute &ldquo;apt-get update&rdquo;</p>

<h1>install packages</h1>

<p>package &ldquo;telnet&rdquo;
package &ldquo;postfix&rdquo;
package &ldquo;curl&rdquo;
package &ldquo;git-core&rdquo;
package &ldquo;zlib1g-dev&rdquo;
package &ldquo;libssl-dev&rdquo;
package &ldquo;libreadline-dev&rdquo;
package &ldquo;libyaml-dev&rdquo;
package &ldquo;libsqlite3-dev&rdquo;
package &ldquo;sqlite3&rdquo;
package &ldquo;libxml2-dev&rdquo;
package &ldquo;libxslt1-dev&rdquo;
package &ldquo;libpq-dev&rdquo;
package &ldquo;build-essential&rdquo;
package &ldquo;tree&rdquo;</p>

<h1>set timezone</h1>

<p>bash &ldquo;set timezone&rdquo; do
  code &lt;&lt;-EOH</p>

<pre><code>echo 'US/Pacific-New' &gt; /etc/timezone
dpkg-reconfigure -f noninteractive tzdata
</code></pre>

<p>  EOH
  not_if &ldquo;date | grep -q &lsquo;PDT\|PST&rsquo;&rdquo;
end
```</p>

<p>Chef uses a domain-specific language (DSL) for writing recipes, and the code above is what it looks like. A recipe is made up of resources, and a resource is simply an abstraction of some shell code you would run to provision your server that Chef already implemented for you and wrapped it in a resource. Chef provides most of the resources you will need, but you can also write your own.</p>

<p>In the file above, we&rsquo;re using three resources: <a href="http://docs.getchef.com/chef/resources.html#execute"><code>execute</code></a>, <a href="http://docs.getchef.com/chef/resources.html#package"><code>package</code></a>, and <a href="http://docs.getchef.com/chef/resources.html#bash"><code>bash</code></a>. The <code>execute</code> resource executes a command, the <code>package</code> resource manages packages, and the <code>bash</code> resource executes scripts using the Bash interpreter. So in the code above, we&rsquo;re first using <code>execute</code> to run <code>apt-get update</code> to fetch the latest updates for the packages on our node. (A server is known as a node in Chef terminology.) Next, we use <code>package</code> to install the various packages our node will need, and finally, we use <code>bash</code> to execute two lines of code that will set the correct time zone (be sure to modify the <code>echo</code> command so it sets your own time zone).</p>

<p>Each resource has various attributes that you can optionally specify inside a <code>do...end</code> block. For example, with the <code>bash</code> resource, we&rsquo;re using the <code>code</code> attribute to specify the code that will run to set the timezone (see the <a href="http://docs.getchef.com/chef/resources.html#bash">documentation</a> to learn about the other attributes it supports). This resource is similar to the <code>execute</code> resource, which also runs commands, but <code>execute</code> is used to run a single command, while <code>bash</code>&rsquo;s <code>code</code> attribute is used to run more than one.</p>

<p>We could&rsquo;ve specified attributes for the <code>execute</code> and <code>package</code> resources as well, but there is no need in this case. For example, this</p>

<p><code>ruby
execute "update packages" do
  command "apt-get update"
end
</code></p>

<p>is equivalent to <code>execute "apt-get update"</code>. The only difference between the two is the longer version gives the resource block a name&mdash;&ldquo;update packages&rdquo; in this case, but it could&rsquo;ve been anything&mdash;while the shorter version just specifies the command to execute. When the <code>command</code> attribute is missing, the resource name is the command that is executed, and that&rsquo;s why the shorter version works just as well.</p>

<p>One last interesting thing about the <code>bash</code> resource is the <code>not_if</code> line. This is called a <a href="http://docs.getchef.com/chef/resources.html#guards">guard attribute</a>, and it can be applied to any resource, not just <code>bash</code>. It&rsquo;s used to prevent a resource from running if certain conditions are met. In this case, I&rsquo;m specifying a command that will output the current date and search for either the word &ldquo;PDT&rdquo; (Pacific Daylight Time) or &ldquo;PST&rdquo; (Pacific Standard Time) to see if the correct time zone is set (be sure to modify this for your own time zone). The guard will be applied and the resource won&rsquo;t run if the command returns <code>0</code>, which is the case with <code>grep</code> when it finds a match.</p>

<h2>Working with Users</h2>

<p>This next recipe will create a new user and group. Add a new file called <code>users.rb</code> to the directory containing the previous recipe, and fill it with the following:</p>

<p>``` ruby users.rb</p>

<h1>create group</h1>

<p>group node[&lsquo;group&rsquo;]</p>

<h1>create user and add to group</h1>

<p>user node[&lsquo;user&rsquo;][&lsquo;name&rsquo;] do
  gid node[&lsquo;group&rsquo;]
  home &ldquo;/home/#{node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]}&rdquo;
  password node[&lsquo;user&rsquo;][&lsquo;password&rsquo;]
  shell &ldquo;/bin/bash&rdquo;
  supports manage_home: true # need for /home creation
end</p>

<h1>give group sudo privileges</h1>

<p>bash &ldquo;give group sudo privileges&rdquo; do
  code &lt;&lt;-EOH</p>

<pre><code>sed -i '/%#{node['group']}.*/d' /etc/sudoers
echo '%#{node['group']} ALL=(ALL) ALL' &gt;&gt; /etc/sudoers
</code></pre>

<p>  EOH
  not_if &ldquo;grep -xq &lsquo;%#{node['group&rsquo;]} ALL=(ALL) ALL' /etc/sudoers&rdquo;
end
```</p>

<p>Here we&rsquo;re first using the <a href="http://docs.getchef.com/chef/resources.html#group"><code>group</code> resource</a> to create a new group whose name will come from the <code>group</code> attribute defined in the JSON file we created earlier. Note the syntax to access that attribute; it stays the same whether you&rsquo;re accessing attributes from the JSON file or the <code>default.rb</code> file.</p>

<p>Next, we use the <a href="http://docs.getchef.com/chef/resources.html#user"><code>user</code> resource</a> to create a new user whose name is also defined in the JSON file. But now it gets interesting because there are a handful of additional attributes we&rsquo;re using:</p>

<ul>
<li><code>gid</code> assigns this user to the group we created right before</li>
<li><code>home</code> specifies the location of the user&rsquo;s home directory</li>
<li><code>password</code> accepts a shadow hash of the users password</li>
<li><code>shell</code> specifies the login shell that the user will log in with (user won&rsquo;t have login access without this attribute)</li>
<li><code>supports</code> sets <code>manage_home</code> to <code>true</code> to tell Chef to create the home directory when the user is created</li>
</ul>


<p>The last <code>bash</code> resource adds a line to the <code>sudoers</code> file that gives the group <code>sudo</code> privileges, but it does this only if the line isn&rsquo;t already there.</p>

<h1>Restricting SSH Access</h1>

<p>The next thing on our list is restricting SSH access to our node. Add the following code into a new file called <code>ssh.rb</code>:</p>

<p>``` ruby ssh.rb</p>

<h1>tell chef about ssh service</h1>

<p>service &lsquo;ssh&rsquo; do
  provider Chef::Provider::Service::Upstart
  supports [:status, :restart]
end</p>

<h1>modify port</h1>

<p>bash &ldquo;modify port&rdquo; do
  code &lt;&lt;-EOH</p>

<pre><code>sed -i '/Port.*/d' /etc/ssh/sshd_config
echo 'Port #{node['port']}' &gt;&gt; /etc/ssh/sshd_config
</code></pre>

<p>  EOH
  notifies :restart, &ldquo;service[ssh]&rdquo;, :delayed
  not_if &ldquo;grep -xq &lsquo;Port #{node['port&rsquo;]}&lsquo; /etc/ssh/sshd_config&rdquo;
end</p>

<h1>disable root login</h1>

<p>bash &ldquo;disable root login&rdquo; do
  code &lt;&lt;-EOH</p>

<pre><code>sed -i '/PermitRootLogin.*/d' /etc/ssh/sshd_config
echo 'PermitRootLogin no' &gt;&gt; /etc/ssh/sshd_config
</code></pre>

<p>  EOH
  notifies :restart, &ldquo;service[ssh]&rdquo;, :delayed
  not_if &ldquo;grep -xq &lsquo;PermitRootLogin no&rsquo; /etc/ssh/sshd_config&rdquo;
end</p>

<h1>restrict login only to created user</h1>

<p>bash &ldquo;restrict login only to created user&rdquo; do
  code &lt;&lt;-EOH</p>

<pre><code>sed -i '/AllowUsers.*/d' /etc/ssh/sshd_config
echo 'AllowUsers #{node['user']['name']}' &gt;&gt; /etc/ssh/sshd_config
</code></pre>

<p>  EOH
  notifies :restart, &ldquo;service[ssh]&rdquo;, :delayed
  not_if &ldquo;grep -xq &lsquo;AllowUsers #{node['user&rsquo;][&lsquo;name&rsquo;]}&lsquo; /etc/ssh/sshd_config&rdquo;
end</p>

<h1>disable dns</h1>

<p>bash &ldquo;disable dns&rdquo; do
  code &lt;&lt;-EOH</p>

<pre><code>sed -i '/UseDNS.*/d' /etc/ssh/sshd_config
echo 'UseDNS no' &gt;&gt; /etc/ssh/sshd_config
</code></pre>

<p>  EOH
  notifies :restart, &ldquo;service[ssh]&rdquo;, :delayed
  not_if &ldquo;grep -xq &lsquo;UseDNS no&rsquo; /etc/ssh/sshd_config&rdquo;
end
```</p>

<p>Chef has a <a href="http://docs.getchef.com/chef/resources.html#service"><code>service</code> resource</a> designed for managing services like SSH. We tell it to manage SSH by specifying &ldquo;ssh&rdquo; as the resource name, and since we don&rsquo;t have a <code>service_name</code> attribute listed, Chef automatically assumes that the resource name is also the name of the service we want to manage.</p>

<p>We then use the <code>provider</code> attribute to tell Chef to use <a href="https://en.wikipedia.org/wiki/Upstart">upstart</a> to manage the service. This is necessary whenever there are two or more ways available for managing a service, which is the case with SSH on the node I&rsquo;m running. My node has an upstart job (located in <code>/etc/init</code>) and a traditional init script (located in <code>/etc/init.d</code>) for managing SSH, and I decided to go with upstart since it&rsquo;s superior, but either will work for our purposes. If there is only one service provider available, Chef will detect it automatically, and there is no need for the <code>provider</code> attribute.</p>

<p>By default, Chef inspects the process table to see if a service is running, but it&rsquo;s also possible to use the <code>service ssh status</code> command (which is more reliable) to do the same thing. That&rsquo;s why we use the <code>supports</code> attribute to tell Chef to use the <code>status</code> command instead. And while we&rsquo;re at it, we also give Chef permission to use the <code>restart</code> command to restart SSH.</p>

<p>Once the service is defined, we use the <code>bash</code> resource to modify the SSH port, disable <code>root</code> login, restrict login access just to our created user, and disable DNS lookup. Each <code>bash</code> block also uses the <a href="http://docs.getchef.com/chef/resources.html#notifications"><code>notifies</code> attribute</a> to tell the SSH <code>service</code> resource we just defined to restart itself <em>if</em> the code inside the <code>code</code> attribute actually runs. But we use the <code>delayed</code> timer to tell Chef to queue up the notification and run in at the very end. The other option is to use the <code>immediate</code> timer to do the restart immediately, but we don&rsquo;t want to restart the service four separate times when we can just wait till the end and do it just once.</p>

<p>And just like in the two previous recipes, we use the <code>not_if</code> guard to make  sure the <code>bash</code> resources don&rsquo;t run if the necessary changes are already made.</p>

<h2>Installing Node.js</h2>

<p>Next order of business is installing Node.js. Add the following code into a new file called <code>nodejs.rb</code>:</p>

<p>``` ruby nodejs.rb</p>

<h1>variables for node.js</h1>

<p>arch = node[&lsquo;kernel&rsquo;][&lsquo;machine&rsquo;] =~ /x86_64/ ? &ldquo;x64&rdquo; : &ldquo;x86&rdquo;
package_stub = &ldquo;node-v#{node[&lsquo;nodejs&rsquo;][&lsquo;version&rsquo;]}-linux-#{arch}&rdquo;
nodejs_tar = &ldquo;#{package_stub}.tar.gz&rdquo;
nodejs_url = &ldquo;<a href="http://nodejs.org/dist/v#">http://nodejs.org/dist/v#</a>{node[&lsquo;nodejs&rsquo;][&lsquo;version&rsquo;]}/#{nodejs_tar}&rdquo;
executable = &ldquo;#{node[&lsquo;nodejs&rsquo;][&lsquo;dir&rsquo;]}/bin/node&rdquo;</p>

<h1>download tar file</h1>

<p>remote_file &ldquo;/usr/local/src/#{nodejs_tar}&rdquo; do
  source nodejs_url
  mode 0644
  action :create_if_missing
end</p>

<h1>install node.js from binaries</h1>

<p>execute &ldquo;install node.js&rdquo; do
  command &lt;&lt;-EOF</p>

<pre><code>tar xf /usr/local/src/#{nodejs_tar} \
--strip-components=1 --no-same-owner \
-C #{node['nodejs']['dir']} \
#{package_stub}/bin \
#{package_stub}/lib \
#{package_stub}/share
</code></pre>

<p>  EOF
  not_if { File.exists?(executable) &amp;&amp; <code>#{node['nodejs']['dir']}/bin/node --version</code>.chomp == &ldquo;v#{node[&lsquo;nodejs&rsquo;][&lsquo;version&rsquo;]}&rdquo; }
end
```</p>

<p>The very first line makes use of <a href="http://docs.getchef.com/ohai.html">Ohai</a>, a tool Chef uses to detect attributes on a node and make them available for use in recipes. We&rsquo;re extracting the type of architecture our node is running on to make sure we download the correct tar file for installing Node.js.</p>

<p>We download the tar file using a resource called <a href="http://docs.getchef.com/chef/resources.html#remote-file"><code>remote_file</code></a>, and we then use the <code>source</code> attribute to specify the source of the tar file, <code>mode</code> to specify its mode, and <code>action</code> to tell Chef to create the file only if it&rsquo;s not already there.</p>

<p>One interesting thing about the <code>action</code> attribute is it&rsquo;s actually present in each resource we write, whether we explicitly assign one or not. Not every resource has the same actions though. <code>remote_file</code>, for example, has <code>create</code>, <code>create_if_missing</code>, <code>delete</code>, and <code>touch</code> actions, while <code>bash</code> only has <code>run</code> and <code>nothing</code> actions. But every resource is assigned a default action, if we don&rsquo;t assign one ourselves (the resource&rsquo;s documentation will specify which action is assigned by default).</p>

<p>After the file is downloaded, we use <code>execute</code> to do the install. One interesting thing about this resource is the <code>not_if</code> guard, which executes some Ruby code, whereas the previous one only executed shell commands. Guards  can run a shell command specified inside a string, or Ruby code specified inside a block. Ruby code must return either <code>true</code> or <code>false</code>, while shell commands can return any value, but the guard runs only if a zero is returned (see the <a href="http://docs.getchef.com/chef/resources.html#guards">documentation</a>).</p>

<p>So in the code above, we&rsquo;re first executing some Ruby code to determine if a file exists, and then we execute a shell command to output the Node.js version we installed, but this output is processed by Ruby and gets compared with the version we&rsquo;ve specified in our attributes file. As a result, Node.js won&rsquo;t be installed if there is a Node.js executable already present on the node that returns the correct version number. (Note that shell commands will be processed by Ruby only if they&rsquo;re specified using backquotes).</p>

<h2>Installing PostgreSQL</h2>

<p>Our next recipe will install PostgreSQL. Create a new file called <code>postgres.rb</code>, and add the following code into it:</p>

<p>``` ruby postgres.rb
package &ldquo;postgresql&rdquo;
package &ldquo;postgresql-contrib&rdquo;</p>

<h1>change postgres password</h1>

<p>execute &ldquo;change postgres password&rdquo; do
  user &ldquo;postgres&rdquo;
  command &ldquo;psql -c \"alter user postgres with password &lsquo;#{node['db&rsquo;][&lsquo;root_password&rsquo;]}&lsquo;;\&rdquo;&ldquo;
end</p>

<h1>create new postgres user</h1>

<p>execute &ldquo;create new postgres user&rdquo; do
  user &ldquo;postgres&rdquo;
  command &ldquo;psql -c \"create user #{node[&lsquo;db&rsquo;][&lsquo;user&rsquo;][&lsquo;name&rsquo;]} with password &lsquo;#{node['db&rsquo;][&lsquo;user&rsquo;][&lsquo;password&rsquo;]}&lsquo;;\&rdquo;&ldquo;
  not_if { <code>sudo -u postgres psql -tAc \"SELECT * FROM pg_roles WHERE rolname='#{node['db']['user']['name']}'\" | wc -l</code>.chomp == "1&rdquo; }
end</p>

<h1>create new postgres database</h1>

<p>execute &ldquo;create new postgres database&rdquo; do
  user &ldquo;postgres&rdquo;
  command &ldquo;psql -c \"create database #{node[&lsquo;app&rsquo;]} owner #{node[&lsquo;db&rsquo;][&lsquo;user&rsquo;][&lsquo;name&rsquo;]};\&rdquo;&ldquo;
  not_if { <code>sudo -u postgres psql -tAc \"SELECT * FROM pg_database WHERE datname='#{node['app']}'\" | wc -l</code>.chomp == "1&rdquo; }
end
```</p>

<p>This recipe is fairly straightforward. We install Postgres using the <code>package</code> resource and use <code>execute</code> to modify the <code>postgres</code> user&rsquo;s password. We also create new user, along with a new database, which is assigned to the newly created user. (Note that we&rsquo;re using the <code>user</code> attribute to execute these commands as the <code>postgres</code> user, which is necessary because otherwise Postgres would run these commands as <code>root</code>, and such a user does not exist in Postgres by default.)</p>

<h2>Installing rbenv and Ruby</h2>

<p>It&rsquo;s now time to install rbenv and Ruby. Add the following code into a new file called <code>rbenv.rb</code>:</p>

<p>``` ruby rbenv.rb</p>

<h1>create .bash_profile file</h1>

<p>cookbook_file &ldquo;/home/#{node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]}/.bash_profile&rdquo; do
  source &ldquo;bash_profile&rdquo;
  mode 0644
  owner node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]
  group node[&lsquo;group&rsquo;]
end</p>

<h1>install rbenv</h1>

<p>bash &lsquo;install rbenv&rsquo; do
  user node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]
  cwd &ldquo;/home/#{node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]}&rdquo;
  code &lt;&lt;-EOH</p>

<pre><code>export HOME=/home/#{node['user']['name']}
curl -L https://raw.github.com/fesplugas/rbenv-installer/master/bin/rbenv-installer | bash
</code></pre>

<p>  EOH
  not_if { File.exists?(&ldquo;/home/#{node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]}/.rbenv/bin/rbenv&rdquo;) }
end</p>

<h1>install ruby</h1>

<p>version_path = &ldquo;/home/#{node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]}/.rbenv/version&rdquo;
bash &lsquo;install ruby&rsquo; do
  user node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]
  cwd &ldquo;/home/#{node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]}&rdquo;
  code &lt;&lt;-EOH</p>

<pre><code>export HOME=/home/#{node['user']['name']}
export RBENV_ROOT="${HOME}/.rbenv"
export PATH="${RBENV_ROOT}/bin:${PATH}"
rbenv init -

rbenv install #{node['ruby']['version']}
rbenv global #{node['ruby']['version']}
echo 'gem: -–no-ri -–no-rdoc' &gt; .gemrc
.rbenv/bin/rbenv exec gem install bundler
rbenv rehash
</code></pre>

<p>  EOH
  not_if { File.exists?(version_path) &amp;&amp; <code>cat #{version_path}</code>.chomp.split[0] == node[&lsquo;ruby&rsquo;][&lsquo;version&rsquo;] }
end
```</p>

<p>We&rsquo;re using a new resource here called <a href="http://docs.getchef.com/chef/resources.html#cookbook-file"><code>cookbook_file</code></a>, which takes a file in our recipe and copies it to a specific location on our node. The file were creating is called <code>bash_profile</code>, and it contains some code that allows rbenv to initialize itself properly (store it in your cookbook&rsquo;s <code>/files/default</code> directory):</p>

<p>``` bash bash_profile
export RBENV_ROOT=&ldquo;${HOME}/.rbenv&rdquo;</p>

<p>if [ -d &ldquo;${RBENV_ROOT}&rdquo; ]; then
  export PATH=&ldquo;${RBENV_ROOT}/bin:${PATH}&rdquo;
  eval &ldquo;$(rbenv init &ndash;)&rdquo;
fi
```</p>

<p>If you go back to the <code>cookbook_file</code> resource, you&rsquo;ll see that we&rsquo;re copying the file to the user&rsquo;s home directory (since we did not specify a <code>path</code> attribute, the resource&rsquo;s name is also the path to the location where it will be stored), and we&rsquo;re using the <code>mode</code>, <code>owner</code>, and <code>group</code> attributes to set the file&rsquo;s mode, owner, and group, respectively.</p>

<p>Afterwards, we&rsquo;re using <code>bash</code> to install rbenv. Because we&rsquo;re not doing a system-wide install, we run the rbnev installer under the user we created earlier, and we use the <code>cwd</code> attribute to run the install inside the user&rsquo;s home directory. Once that&rsquo;s done, the last <code>bash</code> block then uses rbenv to install Ruby itself.</p>

<h2>Installing Redis</h2>

<p>Next in line is Redis, so go ahead and create a new file called <code>redis.rb</code>:</p>

<p>``` ruby redis.rb
package &ldquo;tcl8.5&rdquo;</p>

<h1>download redis</h1>

<p>remote_file &ldquo;/home/#{node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]}/redis-#{node[&lsquo;redis&rsquo;][&lsquo;version&rsquo;]}.tar.gz&rdquo; do
  source &ldquo;<a href="http://download.redis.io/releases/redis-#">http://download.redis.io/releases/redis-#</a>{node[&lsquo;redis&rsquo;][&lsquo;version&rsquo;]}.tar.gz&rdquo;
  mode 0644
  action :create_if_missing
end</p>

<h1>install redis</h1>

<p>bash &lsquo;install redis&rsquo; do
  cwd &ldquo;/home/#{node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]}&rdquo;
  code &lt;&lt;-EOH</p>

<pre><code>tar xzf redis-#{node['redis']['version']}.tar.gz
cd redis-#{node['redis']['version']}
make &amp;&amp; make install
</code></pre>

<p>  EOH
  not_if { File.exists?(&ldquo;/usr/local/bin/redis-server&rdquo;) &amp;&amp;</p>

<pre><code>       `redis-server --version`.chomp.split[2] == "v=#{node['redis']['version']}" }
</code></pre>

<p>end</p>

<h1>install redis server</h1>

<p>execute &ldquo;curl -L <a href="https://gist.githubusercontent.com/vladigleba/28f4f6b4454947c5223e/raw">https://gist.githubusercontent.com/vladigleba/28f4f6b4454947c5223e/raw</a> | sh&rdquo; do
  cwd &ldquo;/home/#{node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]}/redis-#{node[&lsquo;redis&rsquo;][&lsquo;version&rsquo;]}/utils&rdquo;
  not_if &ldquo;ls /etc/init.d | grep redis&rdquo;
end
```</p>

<p>This recipe doesn&rsquo;t contain any new Chef concepts. It simply downloads Redis using the <code>remote_file</code> resource, installs it using the <code>bash</code> resource, and installs the Redis server with the <code>execute</code> resource.</p>

<h2>Installing Nginx</h2>

<p>The last thing left to install is Nginx, and here&rsquo;s the code that will go in a new <code>nginx.rb</code> file to do just that:</p>

<p>``` ruby nginx.rb
package &ldquo;nginx&rdquo;</p>

<h1>remove default nginx config</h1>

<p>default_path = &ldquo;/etc/nginx/sites-enabled/default&rdquo;
execute &ldquo;rm -f #{default_path}&rdquo; do
  only_if { File.exists?(default_path) }
end</p>

<h1>start nginx</h1>

<p>service &ldquo;nginx&rdquo; do
  supports [:status, :restart]
  action :start
end</p>

<h1>set custom nginx config</h1>

<p>template &ldquo;/etc/nginx/sites-enabled/#{node[&lsquo;app&rsquo;]}&rdquo; do
  source &ldquo;nginx.conf.erb&rdquo;
  mode 0644
  owner node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]
  group node[&lsquo;group&rsquo;]
  notifies :restart, &ldquo;service[nginx]&rdquo;, :delayed
end
```</p>

<p>There is only one new Chef concept here, and that&rsquo;s the <a href="http://docs.getchef.com/chef/resources.html#template"><code>template</code> resource</a>. It&rsquo;s similar to the <code>cookbook_file</code> resource in that it copies a file from a cookbook to a location on a node, but it also does much more than that; it allows you to modify the contents of the file by embedding Ruby code into it using ERB (Embedded Ruby) templates, just like you would if you wrote Ruby on Rails views in ERB. All the attributes that are accessible in your recipes are also accessible in template files, and when you combine this with the usual ERB features like conditional statements and blocks, you&rsquo;ll be able to customize your files in any way you want.</p>

<p>Templates are stored in your cookbook&rsquo;s <code>/templates</code> directory, so go ahead and create a new file there called <code>nginx.conf.erb</code> with the following code (note that the syntax for accessing attributes doesn&rsquo;t change):</p>

<p>``` erb nginx.conf.erb
upstream unicorn {
  server unix:/tmp/unicorn.&lt;%= node[&lsquo;app&rsquo;] %>.sock fail_timeout=0;
}</p>

<p>server {
  server_name www.&lt;%= node[&lsquo;app&rsquo;] %>.com;
  return 301 $scheme://&lt;%= node[&lsquo;app&rsquo;] %>.com$request_uri;
}</p>

<p>server {
  listen 80 default deferred;
  server_name &lt;%= node[&lsquo;app&rsquo;] %>.com;
  root /var/www/&lt;%= node[&lsquo;app&rsquo;] %>/current/public;</p>

<p>  location ^~ /assets/ {</p>

<pre><code>gzip_static on;
expires max;
add_header Cache-Control public;
</code></pre>

<p>  }</p>

<p>  try_files $uri/index.html $uri @unicorn;
  location @unicorn {</p>

<pre><code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header Host $http_host;
proxy_redirect off;
proxy_pass http://unicorn;
</code></pre>

<p>  }</p>

<p>  error_page 500 502 503 504 /500.html;
  keepalive_timeout 5;
}
```</p>

<p>This is the file we&rsquo;re referencing inside the <code>template</code> resource in <code>nginx.rb</code>. You&rsquo;ll notice the attributes we specify there are very similar to those specified in the <code>cookbook_file</code> resources we wrote earlier. But one thing that&rsquo;s different is we&rsquo;re also using the <code>notifies</code> attribute to call <code>restart</code> on the previously defined Nginx service, which allows the new configuration file to be loaded in.</p>

<h2>App Setup</h2>

<p>Our final recipe does some setup for our Rails application. Here&rsquo;s the code you&rsquo;ll need to add to a new file called <code>app.rb</code>:</p>

<p>``` ruby app.rb</p>

<h1>create www directory</h1>

<p>directory &ldquo;/var/www&rdquo; do
  user node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]
  group node[&lsquo;group&rsquo;]
  mode 0755
end</p>

<h1>create shared directory structure for app</h1>

<p>path = &ldquo;/var/www/#{node[&lsquo;app&rsquo;]}/shared/config&rdquo;
execute &ldquo;mkdir -p #{path}&rdquo; do
  user node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]
  group node[&lsquo;group&rsquo;]
  creates path
end</p>

<h1>create database.yml file</h1>

<p>template &ldquo;#{path}/database.yml&rdquo; do
  source &ldquo;database.yml.erb&rdquo;
  mode 0640
  owner node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]
  group node[&lsquo;group&rsquo;]
end</p>

<h1>set unicorn config</h1>

<p>template &ldquo;/etc/init.d/unicorn_#{node[&lsquo;app&rsquo;]}&rdquo; do
  source &ldquo;unicorn.sh.erb&rdquo;
  mode 0755
  owner node[&lsquo;user&rsquo;][&lsquo;name&rsquo;]
  group node[&lsquo;group&rsquo;]
end</p>

<h1>add init script link</h1>

<p>execute &ldquo;update-rc.d unicorn<em>#{node[&lsquo;app&rsquo;]} defaults&rdquo; do
  not_if &ldquo;ls /etc/rc2.d | grep unicorn</em>#{node[&lsquo;app&rsquo;]}&rdquo;
end
```</p>

<p>The only new resource here is <a href="http://docs.getchef.com/chef/resources.html#directory"><code>directory</code></a>, which we use to create a new <code>/var/www</code> directory for our Rails app. One other new thing is the <code>creates</code> attribute inside the second <code>execute</code> resource, which is used to prevent the resource from creating the <code>/var/www/phindee/shared/config</code> directory if it already exists. If you&rsquo;re wondering why we&rsquo;re using <code>execute</code> and not <code>directory</code>, it&rsquo;s because it&rsquo;s pretty messy to create recursive directories using <code>directory</code>, and this just seems cleaner to me.</p>

<p>And finally, here are the two template files we&rsquo;re referencing inside the <code>template</code> resources above:</p>

<p><code>erb database.yml.erb
production:
  adapter: postgresql
  encoding: unicode
  database: &lt;%= node['app'] %&gt;
  pool: 5
  host: localhost
  username: &lt;%= node['db']['user']['name'] %&gt;
  password: &lt;%= node['db']['user']['password'] %&gt;
</code>
``` erb unicorn.sh.erb</p>

<h1>!/bin/sh</h1>

<p>set -e</p>

<h1>Example init script, this can be used with nginx, too,</h1>

<h1>since nginx and unicorn accept the same signals</h1>

<h1>Feel free to change any of the following variables for your app:</h1>

<p>TIMEOUT=${TIMEOUT-60}
APP_ROOT=/var/www/&lt;%= node[&lsquo;app&rsquo;] %>/current
PID=$APP_ROOT/tmp/pids/unicorn.pid
CMD=&ldquo;cd $APP_ROOT; ~/.rbenv/bin/rbenv exec bundle exec unicorn -D -c $APP_ROOT/config/unicorn.rb -E production&rdquo;
AS_USER=&lt;%= node[&lsquo;user&rsquo;][&lsquo;name&rsquo;] %>
set -u</p>

<p>OLD_PIN=&ldquo;$PID.oldbin&rdquo;</p>

<p>sig () {
  test -s &ldquo;$PID&rdquo; &amp;&amp; kill &ndash;$1 <code>cat $PID</code>
}</p>

<p>oldsig () {
  test -s $OLD_PIN &amp;&amp; kill &ndash;$1 <code>cat $OLD_PIN</code>
}</p>

<p>run () {
  if [ &ldquo;$(id -un)&rdquo; = &ldquo;$AS_USER&rdquo; ]; then</p>

<pre><code>eval $1
</code></pre>

<p>  else</p>

<pre><code>su -c "$1" - $AS_USER
</code></pre>

<p>  fi
}</p>

<p>case &ldquo;$1&rdquo; in
start)
  sig 0 &amp;&amp; echo >&amp;2 &ldquo;Already running&rdquo; &amp;&amp; exit 0
  run &ldquo;$CMD&rdquo;
  ;;
stop)
  sig QUIT &amp;&amp; exit 0
  echo >&amp;2 &ldquo;Not running&rdquo;
  ;;
force-stop)
  sig TERM &amp;&amp; exit 0
  echo >&amp;2 &ldquo;Not running&rdquo;
  ;;
restart|reload)
  sig HUP &amp;&amp; echo reloaded OK &amp;&amp; exit 0
  echo >&amp;2 &ldquo;Couldn&rsquo;t reload, starting &lsquo;$CMD&rsquo; instead&rdquo;
  run &ldquo;$CMD&rdquo;
  ;;
upgrade)
  if sig USR2 &amp;&amp; sleep 2 &amp;&amp; sig 0 &amp;&amp; oldsig QUIT</p>

<pre><code>then
n=$TIMEOUT
while test -s $OLD_PIN &amp;&amp; test $n -ge 0
do
  printf '.' &amp;&amp; sleep 1 &amp;&amp; n=$(( $n - 1 ))
done
echo

if test $n -lt 0 &amp;&amp; test -s $OLD_PIN
then
  echo &gt;&amp;2 "$OLD_PIN still exists after $TIMEOUT seconds"
  exit 1
fi
exit 0
</code></pre>

<p>  fi
  echo >&amp;2 &ldquo;Couldn&rsquo;t upgrade, starting &lsquo;$CMD&rsquo; instead&rdquo;
  run &ldquo;$CMD&rdquo;
  ;;
reopen-logs)
  sig USR1
  ;;
*)
  echo >&amp;2 &ldquo;Usage: $0 &lt;start|stop|restart|upgrade|force-stop|reopen-logs>&rdquo;
  exit 1
  ;;
esac
```</p>

<p>And with that, our recipes are complete! We&rsquo;re now ready to use them to provision our node, and that&rsquo;s exactly what we&rsquo;ll cover in <a href="/blog/2014/08/13/provisioning-a-rails-server-using-chef-part-3-tying-it-all-together/">part 3</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Provisioning a Rails Server Using Chef, Part 1: Introduction to Chef Solo]]></title>
    <link href="http://vladigleba.github.io/blog/2014/07/28/provisioning-a-rails-server-using-chef-part-1-introduction-to-chef-solo/"/>
    <updated>2014-07-28T14:31:00-07:00</updated>
    <id>http://vladigleba.github.io/blog/2014/07/28/provisioning-a-rails-server-using-chef-part-1-introduction-to-chef-solo</id>
    <content type="html"><![CDATA[<p>About a month ago, I was in the middle of upgrading the server running <a href="http://phindee.com/">Phindee</a> using the harmless (or so I thought) <code>apt-get upgrade</code>. All appeared to be going well. But when I visited the app in the browser, staring back at me was the infamous &ldquo;We&rsquo;re sorry, but something went wrong&rdquo; page. I hit the logs, and luckily, it turned out to be a minor problem that was fixable without too much downtime.</p>

<!-- more -->


<p>But what if I wasn&rsquo;t so lucky and the problem wasn&rsquo;t as easy to fix? What if my server was wrecked and I had to rebuild it from scratch? That would be a nightmare because I would need to provision everything manually&mdash;by hand!  There had to be a better way of doing this.</p>

<p>Since my server was running on <a href="http://digitalocean.com/">DigitalOcean</a>, one possible solution was to take a snapshot of it in a fully-provisioned state and use that for future rebuilding. But this would tie me to DigitalOcean, which I love, but I still like having the freedom to switch providers freely if the need arises.</p>

<p>Another solution was to write a script that executed all the commands I ran to provision the server manually, and this would work, but I had also heard about a tool called <a href="https://github.com/opscode/chef">Chef</a> that&rsquo;s specifically designed for these kinds of things, and I wanted to see if it was something I could use. After a bit of research, I decided to give it a try. Fast forward a couple weeks, and I&rsquo;m now able to provision a Rails server from scratch with a single command. It&rsquo;s really cool, and it makes me feel like a badass.</p>

<h1>Why Chef?</h1>

<p>Besides Chef, there is another popular tool you could use to provision your server called <a href="https://github.com/puppetlabs/puppet">Puppet</a>. There are some <a href="https://www.quora.com/What-are-the-key-reasons-to-choose-Puppet-over-Chef-or-vice-versa">good</a> <a href="http://devopsanywhere.blogspot.com/2011/10/puppet-vs-chef-fight.html">articles</a> comparing the two, but the main reason why I went with Chef is because Puppet was designed with system administrators in mind, while Chef was designed with developers in mind, and as a developer, Chef is more natural for me to work with because it feels a lot like programming. Each tool has its strengths and weaknesses though, and you should pick the one that best fits <em>your</em> needs.</p>

<p>You might not even need Puppet or Chef at all. If you just need to provision a single server every now and then, a simple shell script will probably do. I decided to learn Chef because I do server provisioning pretty often, so it&rsquo;ll save me a significant amount of time down the road.</p>

<p>One thing that a tool like Chef offers is idempotence, which means you&rsquo;re able to run something over and over again safely. With Chef (and Puppet), you&rsquo;re not only able to provision your server, but you can also use it to verify that your server is in the state it&rsquo;s supposed to be in and correct it if it&rsquo;s not. So if the initial server permissions or configuration settings change, you can easily bring them back to their original state by rerunning your recipe. You can&rsquo;t really say the same thing about a shell script (unless you do a significant amount of extra work).</p>

<p>Puppet and Chef also allow you to easily access information about your system, such as kernel name, version, and release, in a way that works across platforms. They make it easy to run your recipes against multiple servers too. But perhaps most importantly, they make your recipes readable, and that&rsquo;s almost worth it on its own.</p>

<h1>Chef Solo or Chef Server?</h1>

<p>Chef comes in two flavors: Chef Solo and Chef Server. Chef Solo is a basically a simpler version of Chef Server because it&rsquo;s designed to be used with a small number of servers. With Chef Solo, you write your recipes on your local computer, upload them to your server(s), and Chef Solo is then called to run them. (A recipe, by the way, is a file containing the commands that will run to provision your server.)</p>

<p>With Chef Server, you still write your recipes on your local computer, but instead of uploading them to the server you want provisioned, you upload them to a server that&rsquo;s specifically dedicated to Chef. This server acts as the main repository of <em>all</em> your recipes. The servers you want provisioned will then have a program running on them (referred to as a Chef client) that is in constant communication with your Chef server, and whenever you upload your recipes to Chef server, Chef client will notice this and run them automatically. (Chef Solo is also Chef client; it just doesn&rsquo;t need a Chef server to do its job.)</p>

<p>Since Phindee is running on a single server, I currently have no need for Chef Server; Chef Solo does everything I need it to. Chef is a complex tool, and I found that there is enough new things to learn without the added complexity of Chef Server. If you&rsquo;re new to Chef, this is the route I recommend, even if you intend on using Chef Server, because the learning curve will be much more manageable.</p>

<h1>Working with Chef Solo</h1>

<p>One nice thing about Chef Server is you get to use a command-line tool called Knife that allows you to easily communicate with Chef Server right from your local computer. It gives you commands to easily upload your recipes, for example, among many other things. Unfortunately, it doesn&rsquo;t offer similar commands for Chef Solo, but there is a Knife plugin called <a href="https://github.com/matschaffer/knife-solo">knife-solo</a> that does just this. Since it&rsquo;s a packaged gem, all we need to do is add it to our app&rsquo;s Gemfile on our local computer, and the commands we need will be available automatically:</p>

<p><code>ruby Gemfile
group :development do
  gem 'knife-solo', '~&gt; 0.4.2'
end
</code></p>

<p>When you run <code>bundle</code> to install it, the Chef gem will be installed as well. If you then go into your app&rsquo;s root directory and run <code>knife</code>, you&rsquo;ll see a list of the commands available to you through Knife, including those provided by knife-solo, which will start with <code>knife solo ...</code>.</p>

<h2>Diving In</h2>

<p>Having that installed, we&rsquo;re now ready to start working with Chef Solo. The first thing we&rsquo;ll do is create a configuration file for Knife on our local computer:</p>

<p><code>bash
knife configure -r . --defaults
</code></p>

<p>This will create a new <code>~/.chef</code> directory with a file called <code>knife.rb</code> containing some default configurations. This file is used by Chef Server, so we actually won&rsquo;t need it, but Knife will keep complaining if we don&rsquo;t create it.</p>

<p>Next, go into your app&rsquo;s <code>/config</code> directory and run the following:</p>

<p><code>bash
knife solo init chef
cd chef
</code></p>

<p>This will create a standard Chef directory structure (referred to as a &ldquo;kitchen&rdquo;) inside a directory called <code>/chef</code>. It&rsquo;ll look like this:</p>

<pre><code>chef/
├── cookbooks
├── data_bags
├── environments
├── nodes
├── roles
└── site-cookbooks
</code></pre>

<p>Here is a brief description of each one:</p>

<ul>
<li><code>/cookbooks</code>: holds recipes written by the community</li>
<li><code>/data_bags</code>: stores sensitive configuration for your infrastructure</li>
<li><code>/environments</code>: contains the environments defined for Chef Server</li>
<li><code>/nodes</code>: stores server-specific information</li>
<li><code>/roles</code>: contains the roles defined for Chef Server</li>
<li><code>/site-cookbooks</code>: holds recipes written by you</li>
</ul>


<p>Note that some of these directories are only for Chef Server, but they&rsquo;re created anyway because they&rsquo;re part of the standard Chef directory structure.</p>

<h2>New Chef Terms</h2>

<p>There are some new terms above that I haven&rsquo;t explained yet, so lets briefly go over them.</p>

<p>A cookbook is a collection of one or more recipes that will be run to set up and configure your servers. These servers are known as &ldquo;nodes&rdquo; and each node belongs to an environment. An environment is the stage that a node is in. For example, you can define a &ldquo;testing&rdquo; and a &ldquo;production&rdquo; environment to differentiate between nodes in the testing stage and those in production. We won&rsquo;t need this functionality, and it&rsquo;s actually only available in Chef Server.</p>

<p>A node can also have a role assigned to it that describes what the node does. For example, you can assign nodes running your databases to the database role, while nodes running the actual Rails application are assigned to the application role. This would make sense in a production environment, but in testing, you might have a node running both the database and the application, so you would assign it to both roles.</p>

<p>Data bags are subdirectories containing JSON files that store sensitive configuration for your infrastructure. Because they&rsquo;re used to store confidential information, they can be encrypted. They cannot, however, be assigned to a Chef environment, and should therefore be used to only store truly global configuration details.</p>

<p>We won&rsquo;t be using data bags, environments, or roles with Chef Solo, so these directories will remain empty. Our <code>/cookbooks</code> directory will also remain empty because I won&rsquo;t be using any community-provided cookbooks. They tend to be complex and bloated with code because they support different installation options and they try to cover as many operating systems as possible. I think they&rsquo;re a great way to learn Chef, but when it&rsquo;s time to write a recipe, I prefer to write my own.</p>

<h2>Creating Our Own Cookbook</h2>

<p>All right, with the terms clarified, we&rsquo;re now ready to create our own cookbook. Go ahead and run the following inside the <code>/chef</code> directory we created above (replace &ldquo;phindee&rdquo; with the name of your app):</p>

<p><code>bash
knife cookbook create phindee -o site-cookbooks
</code></p>

<p>This creates a cookbook called &ldquo;phindee&rdquo; and uses the <code>-o</code> option to tell Knife to store it in the <code>/site-cookbooks</code> directory. (Remember, this is the directory for storing our own cookbooks, while the <code>/cookbooks</code> directory is for those written by the community. In fact, anything stored in <code>/cookbooks</code> won&rsquo;t actually be version controlled.)</p>

<p>If you then do an <code>ls</code> inside the cookbook you just created, you&rsquo;ll see what a standard cookbook directory structure looks like. There will be a number of directories listed, but here are the ones you should know about:</p>

<ul>
<li><code>/attributes</code>: stores files that define default values for recipes</li>
<li><code>/files</code>: contains files that are copied and placed on the server</li>
<li><code>metadata.rb</code>: stores metadata about your cookbook, like name, version, dependencies, etc.</li>
<li><code>/recipes</code>: stores the recipes that are part of the cookbook</li>
<li><code>/templates</code>: stores ERB (Embedded Ruby) files that are later converted to configuration files</li>
</ul>


<p>The rest of the directories are for advanced Chef setups, and I won&rsquo;t be explaining them here.</p>

<p>With our cookbook created, we&rsquo;re now ready to start writing the recipes that will provision our Rails server, which I&rsquo;ll cover in <a href="/blog/2014/08/12/provisioning-a-rails-server-using-chef-part-2-writing-the-recipes/">part 2</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backup a Rails Database with the Backup and Whenever Gems]]></title>
    <link href="http://vladigleba.github.io/blog/2014/06/30/backup-a-rails-database-with-the-backup-and-whenever-gems/"/>
    <updated>2014-06-30T16:07:00-07:00</updated>
    <id>http://vladigleba.github.io/blog/2014/06/30/backup-a-rails-database-with-the-backup-and-whenever-gems</id>
    <content type="html"><![CDATA[<p><a href="http://phindee.com/">Phindee</a> users recently got the ability to &ldquo;like&rdquo; happy hours. Up until that point, all my happy hour data was safely stored in a version controlled <code>seed.rb</code> file, but now I was dealing with data that was dynamically generated and not being backed up anywhere. And that is not a good thing.</p>

<!-- more -->


<p>So I went over to <a href="https://www.ruby-toolbox.com/categories/backups">ruby-toolbox.com</a> to familiarize myself with the various backup tools available for Ruby projects. The <a href="https://github.com/meskyanichi/backup">Backup gem</a> caught my eye as it was (and is) the most popular one by far. After reading a bit about it, I was impressed by its ease of use and its extensive <a href="http://meskyanichi.github.io/backup/v4/">list of features</a>. I knew I had to try it out.</p>

<p>Having now used it for a few weeks, I&rsquo;d like to explain how I set it up, so you can take advantage of it as well.</p>

<h1>Setting Up Backup</h1>

<p>Setting up Backup is as straightforward as it gets. Log in to the VPS running your database and install Backup:</p>

<p><code>bash
gem install backup
</code></p>

<p>You can then run <code>backup</code> to familiarize yourself with all the commands it provides. We&rsquo;ll start out by creating a Backup model, which is simply a description of how a backup will work. If you run</p>

<p><code>bash
backup help generate:model
</code></p>

<p>you&rsquo;ll see all the options available for describing how we want our backup to function. Below is the command and options I used to create my model:</p>

<p><code>bash
backup generate:model --trigger=db_backup --databases='postgresql' --storages='scp' --compressor='gzip' --notifiers='mail'
</code></p>

<p>As you can see, I&rsquo;m first using the <code>--trigger</code> option to create a model called <code>db_backup</code>. Then I&rsquo;m using the <code>--databases</code> option to specify that I&rsquo;ll be backing up a PostgreSQL database. (Basides PostgreSQL, Backup also supports MySQL, MongoDB, Redis, and Riak.)</p>

<p>Next, I use <code>--storages</code> to tell Backup how to perform the backup itself. By specifying <code>scp</code>, I&rsquo;m saying that the backup file should be stored on a secondary VPS, and it should be transferred there via <a href="https://en.wikipedia.org/wiki/Secure_copy">SCP</a>. (Ideally, your secondary VPS should be in a location that&rsquo;s different from the VPS running your database.) In addition to SCP, Backup also supports rsync, FTP/SFTP, S3, Dropbox, and <a href="http://meskyanichi.github.io/backup/v4/storages/">a few others</a>.</p>

<p>I then specify that I want my backup to be compressed with gzip (you could also use bzip2, if you&rsquo;d like), and finally, I tell Backup to notify me via email if the backup succeeded or failed. If you dislike email, your other options include Twitter, Prowl, Campfire, Hipchat, and <a href="http://meskyanichi.github.io/backup/v4/notifiers/">others</a>.</p>

<p>Once this command runs, it&rsquo;ll create a <code>~/Backup</code> directory containing two files: <code>config.rb</code> and <code>models/db_backup.rb</code> (named after our trigger). The latter will hold configuration specific to the model we just created, while the former is for common configuration across multiple models. Since we&rsquo;re only creating a single model, we&rsquo;ll only modify the <code>models/db_backup.rb</code> file, which will already contain some code corresponding to the options we just specified.</p>

<p>If you ran the command above, the file should look something like this:</p>

<p>``` ruby db_backup.rb</p>

<h1>encoding: utf-8</h1>

<h1>load login info</h1>

<p>db_config           = YAML.load_file(&lsquo;/var/www/phindee/shared/config/database.yml&rsquo;)[&lsquo;production&rsquo;]
app_config          = YAML.load_file(&lsquo;/var/www/phindee/shared/config/application.yml&rsquo;)</p>

<p>Model.new(:db_backup, &lsquo;backs up ip_addresses table&rsquo;) do</p>

<p>  # PostgreSQL [Database]
  database PostgreSQL do |db|</p>

<pre><code>db.name           = db_config['database']
db.username       = db_config['username']
db.password       = db_config['password']
db.host           = "localhost"
db.only_tables    = ["ip_addresses"]
</code></pre>

<p>  end</p>

<p>  # SCP (Secure Copy) [Storage]
  store_with SCP do |server|</p>

<pre><code>server.username   = app_config['backup_username']
server.password   = app_config['backup_password']
server.ip         = app_config['backup_ip']
server.port       = app_config['backup_port']
server.path       = "~/backups/"
server.keep       = 5
</code></pre>

<p>  end</p>

<p>  # Gzip [Compressor]
  compress_with Gzip</p>

<p>  # Mail [Notifier]
  notify_by Mail do |mail|</p>

<pre><code>mail.on_success         = false
mail.on_warning         = true
mail.on_failure         = true

mail.from               = app_config['email_username']
mail.to                 = app_config['email_username']
mail.address            = app_config['email_address']
mail.port               = app_config['email_port']
mail.domain             = app_config['email_domain']
mail.user_name          = app_config['email_username']
mail.password           = app_config['email_password']
mail.authentication     = :login
mail.encryption         = :ssl
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Since I store my database information in the <code>database.yml</code> file and my email and VPS information in <code>application.yml</code>, I added two lines in the beginning to load the necessary login information from these files using the <code>load_file()</code> method from the YAML module. I recommend you do the same because it&rsquo;s best to keep these things in a dedicated file, instead of hard-coding them in every time.</p>

<p>Let&rsquo;s now go over our <code>db_backup</code> model, which consists of four sections. Because we specified PostgreSQL for the <code>--databases</code> option, the first section contains configuration that is specific to PostgreSQL. It collects our database name, username, password, and host, along with an array of tables to back up. This array is optional and should be used only if you don&rsquo;t want your entire database backed up. (I used it because the <code>ip_addresses</code> table is the only table I&rsquo;m interested in backing up since the data for all my other tables is saved in <code>seed.rb</code>.)</p>

<p>The second section describes how to connect to our secondary VPS. After setting the username, password, IP address, and port, I specify the path where the backups will be stored, and I tell Backup to keep only the five most recent ones. The third section simply tells Backup to use gzip for compression, while the last contains settings for setting up email notifications, which tell Backup to only send an email if a warning or a failure occurs.</p>

<p>Once our <code>db_backup.rb</code> file is configured, we can run it with the following command:</p>

<p><code>bash
backup perform -t db_backup
</code></p>

<p>If all went well, you should be able to find a gzipped backup file on your secondary VPS.</p>

<h1>Setting Up Whenever</h1>

<p>Okay, this is all great, but wouldn&rsquo;t it be cool if the backup was done automatically without you having to trigger it? Well, this is possible with a tool called <a href="https://en.wikipedia.org/wiki/Cron">cron</a>. If you&rsquo;re not familiar with it, cron is a scheduling utility that allows you to run tasks (which are known as cron jobs) at specified times. You can use it to automate any task that needs to be run at regular intervals. If you&rsquo;ve never used it before, DigitalOcean has a good introductory <a href="https://www.digitalocean.com/community/tutorials/how-to-schedule-routine-tasks-with-cron-and-anacron-on-a-vps">article</a> that&rsquo;s definitely worth a read.</p>

<p>To write our cron jobs, we&rsquo;ll be using a gem called <a href="https://github.com/javan/whenever">Whenever</a>, because it allows us to write them in a simpler, more expressive Ruby syntax, instead of the standard cron syntax.</p>

<p>Go ahead and install Whenever on the server running Backup:</p>

<p><code>bash
gem install whenever
</code></p>

<p>When that finishes, create a <code>/config</code> directory for Whenever inside <code>~/Backup</code>:</p>

<p><code>bash
cd ~/Backup
mkdir config
</code></p>

<p>Then run:</p>

<p><code>bash
wheneverize .
</code></p>

<p>This will create a <code>schedule.rb</code> file in <code>~/Backup/config</code> for writing your cron jobs. Below is the code I added to mine:</p>

<p>``` ruby schedule.rb
every 1.day, :at => &lsquo;11:30 pm&rsquo; do
  command &ldquo;backup perform -t db_backup&rdquo;
end</p>

<p>```</p>

<p>The code pretty much explains itself: everyday at 11pm, cron will run the <code>backup perform -t db_backup</code> command. If you&rsquo;d like to see this converted to cron syntax, run <code>whenever</code>:</p>

<p><code>bash
$ whenever
30 23 * * * /bin/bash -l -c 'backup perform -t db_backup &gt;&gt; /home/bob/Backup/config/cron.log 2&gt;&amp;1'
</code></p>

<p>This is known as your crontab (which stands for cron table), and it lists all the jobs cron is scheduled to run, along with the time and day they&rsquo;ll run.</p>

<p>The first column, for example, defines the minute (0-59) at which the command will run, while the second defines the hour (0-23) in military time. The third column defines the day of the month, the fourth defines the month itself (1-12), and the fifth is used to specify the day of the week (with Sunday being represented by both 0 and 7).</p>

<p>Because running <code>whenever</code> didn&rsquo;t actually write our job to crontab, we&rsquo;ll need to run</p>

<p><code>bash
whenever --update-crontab
</code></p>

<p>to do so. Having done that, cron will now know about our job, and it&rsquo;ll get executed at the specified time and day. When it runs, it&rsquo;ll also log its activity in a <code>~/Backup/config/cron.log</code> file for future reference.</p>

<h1>Hooking Things Up with Capistrano</h1>

<p>In order to make it easier to edit these files in the future, I decided to recreate them on my local computer and store them in my app&rsquo;s <code>/config</code> directory in a folder called <code>/backup</code>, which means they&rsquo;ll now be under version control as well. And since I use Capistrano for deployment, I wrote two tasks to automate the process of uploading these files back to the server. They reside in a file called <code>backup.cap</code> in my app&rsquo;s <code>/lib/capistrano/tasks</code> directory:</p>

<p>``` ruby backup.cap
namespace :backup do</p>

<p>  desc &ldquo;Upload backup config files.&rdquo;
  task :upload_config do</p>

<pre><code>on roles(:app) do
  execute "mkdir -p #{fetch(:backup_path)}/models"
  upload! StringIO.new(File.read("config/backup/config.rb")), "#{fetch(:backup_path)}/config.rb"
  upload! StringIO.new(File.read("config/backup/models/db_backup.rb")), "#{fetch(:backup_path)}/models/db_backup.rb"
end
</code></pre>

<p>  end</p>

<p>  desc &ldquo;Upload cron schedule file.&rdquo;
  task :upload_cron do</p>

<pre><code>on roles(:app) do
  execute "mkdir -p #{fetch(:backup_path)}/config"
  execute "touch #{fetch(:backup_path)}/config/cron.log"
  upload! StringIO.new(File.read("config/backup/schedule.rb")), "#{fetch(:backup_path)}/config/schedule.rb"

  within "#{fetch(:backup_path)}" do
    # capistrano was unable to find the executable for whenever
    # without the path to rbenv shims set
    with path: "/home/#{fetch(:deploy_user)}/.rbenv/shims:$PATH" do
      puts capture :whenever
      puts capture :whenever, '--update-crontab'
    end
  end
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>And inside my <code>/config/deploy.rb</code> file, I then have the following definition for the <code>backup_path</code> variable:</p>

<p>``` ruby deploy.rb
&hellip;</p>

<p>set :backup_path, &ldquo;/home/#{fetch(:deploy_user)}/Backup&rdquo;</p>

<p>&hellip;
```</p>

<p>(If this is all new to you, feel free to read my posts explaining <a href="http://vladigleba.com/blog/2014/04/04/deploying-rails-apps-part-5-configuring-capistrano/">how to configure Capistrano</a> and <a href="http://vladigleba.com/blog/2014/04/10/deploying-rails-apps-part-6-writing-capistrano-tasks/">how to write Capistrano tasks</a> to quickly get up to speed.)</p>

<p>And with that, our backup functionality is complete. You&rsquo;ll now have a backup of your database stored on a secondary VPS every 24 hours without you having to lift a finger! And it even notifies you if it fails!</p>

<p>Life is good.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Do Autocomplete in Rails Using Redis]]></title>
    <link href="http://vladigleba.github.io/blog/2014/05/30/how-to-do-autocomplete-in-rails-using-redis/"/>
    <updated>2014-05-30T10:40:00-07:00</updated>
    <id>http://vladigleba.github.io/blog/2014/05/30/how-to-do-autocomplete-in-rails-using-redis</id>
    <content type="html"><![CDATA[<p>A few days ago, I added search functionality to <a href="http://phindee.com/">Phindee</a> so users can quickly find information about a particular happy hour. Search that is well-done often comes with autocomplete, and Phindee is no exception.</p>

<!-- more -->


<p>Autocomplete in Phindee does a couple of things for the user: 1) it reduces typing, 2) it lets the user quickly know if a specific happy hour is in the database, 3) it allows her to quickly find a particular happy hour that <em>is</em> in the database, and 4) it lets him know if the happy hour is currently happening because it will have a green circle next to it if that’s the case.</p>

<p>What makes this work behind the scenes is an open-source, in-memory, key-value store called <a href="https://github.com/antirez/redis/">Redis</a>. Because it’s in-memory, Redis is fast, which makes it perfect for autocompletion. I’ve known about Redis for a while now, but never had a need to use it, so I’m glad the opportunity finally presented itself. But now that I’ve had a chance to work with it, I’d like to explain how the autocomplete functionality works behind the scenes, and hopefully, teach you a few things for your own projects.</p>

<p>Before we go on, it’s important that you have a basic understanding of Redis. If you’re never used it before, I recommend going through the <a href="http://try.redis.io/">interactive tutorial</a> on their website; it will help you understand what it’s for, what it can do, and how to use it. Pay special attention to the section on sorted sets because that’s what we’ll be using for autocompletion.</p>

<h1>Installing Redis</h1>

<p>If you’re on a Mac, you can easily install Redis using <a href="https://github.com/Homebrew/homebrew">Homebrew</a> by running the following command:</p>

<p><code>bash
brew install redis
</code></p>

<p>When it finishes, it’ll give you the command to start the Redis server:</p>

<p><code>bash
redis-server /usr/local/etc/redis.conf
</code></p>

<p>You can then access the Redis command-line by running <code>redis-cli</code>, which allows you to play around with various Redis commands to see how they work.</p>

<p>Next, you’ll need to hook Redis up with your Rails app, and you can do this by adding the following line to your ‘Gemfile’:</p>

<p><code>ruby Gemfile
gem 'redis', '~&gt; 3.0.7'
</code></p>

<p>Then run <code>bundle</code> to install it.</p>

<h1>Defining a Model for Redis to Work With</h1>

<p>First thing we’ll need to do is create an initializer file for setting up our Redis connection. Go ahead and create a file called <code>redis.rb</code> inside your app’s <code>/config/initializers</code> directory. Then add the following line into it:</p>

<p><code>ruby redis.rb
$redis = Redis.new
</code></p>

<p>This creates a global variable called <code>$redis</code> to make it easy for us to access Redis through out our app.</p>

<p>Next, we’ll create a new file called <code>search_suggestion.rb</code> inside the <code>/app/models</code> directory. It will contain the code that seeds our Redis database and retrieves a list of suggestions. To start things off, add the following code into it:</p>

<p>``` ruby search_suggestion.rb
class SearchSuggestion</p>

<p>  def self.seed</p>

<pre><code>Place.find_each do |place|
  name = place.name
  1.upto(name.length - 1) do |n|
    prefix = name[0, n]
    $redis.zadd 'search-suggestions:#{prefix.downcase}', 1, name.downcase
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>This creates a class called <code>SearchSuggestion</code> with a class method called <code>seed()</code>. Notice that this class doesn’t inherit from <code>ActiveRecord::Base</code>, which is the base class that the models you create with <code>rails g model ...</code> inherit from. We don’t need it because we’ll be using Redis instead of ActiveRecord. (By the way, we’re defining a class method instead of an instance method because the logic in this method relates to the class itself, not a specific instance of it.)</p>

<h2>Code Walk-Through</h2>

<p>All right, now let’s go over the code. Phindee has a model called <code>Place</code> for storing all the places that have a happy hour, and I’m simply looping over each record stored in it. The reason why I’m doing <code>Place.find_each</code> instead of <code>Place.all.each</code> is the <code>find_each()</code> method works in batches of 1000. This means that if I have thousands of records in my database, <code>find_each()</code> will load into memory only 1000 at a time, instead of loading them all at once and possibly overwhelming the server, which is the case with <code>Place.all.each</code>.</p>

<p>For each place, I’m using the <code>upto()</code> method to loop over the place’s name n times, where n is the number of characters in the name minus 1 (you’ll see why we’re doing minus 1 later). For example, let’s say the place name is “via delizia”. Our n value would be 10 because the length of the name is 11, but minus 1 brings it down to 10, so we would iterate over the name 10 times.</p>

<p>On the first iteration, n would be 1 and the <code>prefix</code> variable would be set to the string “v” since we’re extracting the characters from 0 to 1. Then the Redis <a href="http://redis.io/commands/zadd"><code>ZADD</code> command</a> is used to create a Sorted Set called “search-suggestions:v” since the variable <code>prefix</code> is set to “v” on the first iteration. (I’m prefixing the set name with “search-suggestions” to keep things organized, but this is not strictly necessary).</p>

<p>Sorted Sets are very similar to Sets because they both store collections of strings, but a Sorted Set also stores an associated score with each string that is then used for sorting. So if we go back to the code, you’ll see that <code>ZADD</code> initializes the set “search-suggestions:v” with a score of 1 and a value of “via delizia”&mdash;the place’s full name.</p>

<p>On the second iteration, a new set will be created called “search-suggestions:vi” since we’re now extracting the characters from 0 to 2, and this initializes the variable <code>prefix</code> to “vi”.  The set itself is then initialized to a score of 1 and a string of “via delizia”, just like the first time.</p>

<p>The same process is then repeated on the subsequent iterations as well. After the 10th iteration, we’ll have 10 different sets initialized to a score of 1 and a string of “via delizia”, like so:</p>

<p>``` bash
&lsquo;search-suggestions:v&rsquo; => [&lsquo;via delizia&rsquo;, 1]</p>

<p>&lsquo;search-suggestions:vi&rsquo; => [&lsquo;via delizia&rsquo;, 1]</p>

<p>&lsquo;search-suggestions:via&rsquo; => [&lsquo;via delizia&rsquo;, 1]</p>

<p>&lsquo;search-suggestions:via &rsquo; => [&lsquo;via delizia&rsquo;, 1]</p>

<p>&lsquo;search-suggestions:via d&rsquo; => [&lsquo;via delizia&rsquo;, 1]</p>

<p>&lsquo;search-suggestions:via de&rsquo; => [&lsquo;via delizia&rsquo;, 1]</p>

<p>&lsquo;search-suggestions:via del&rsquo; => [&lsquo;via delizia&rsquo;, 1]</p>

<p>&lsquo;search-suggestions:via deli&rsquo; => [&lsquo;via delizia&rsquo;, 1]</p>

<p>&lsquo;search-suggestions:via deliz&rsquo; => [&lsquo;via delizia&rsquo;, 1]</p>

<p>&lsquo;search-suggestions:via delizi&rsquo; => [&lsquo;via delizia&rsquo;, 1]
```</p>

<p>Note that we don’t create a last set called “search-suggestions:via delizia” because there is no point in returning “via delizia” as a suggested term when a user types “via delizia”. That’s why we added the minus 1 to the length of the name.</p>

<p>By the way, all the scores are identical right now, but they can be incremented later to increase the ranking of popular search terms, although I won&rsquo;t be covering how to do this here.</p>

<p>Let’s now assume the second place name is “vault martini”. This means that on the very first iteration, with the <code>prefix</code> variable set to “v” once again, there will be no new set created since we already have a set called “search-suggestions:v”. <code>ZADD</code> will recognize this and add to the already existing set, instead. This means that the set “search-suggestions:v” will now hold two keys:</p>

<p><code>
'search-suggestions:v' =&gt; [['via delizia', 1], ['vault martini', 1]]
</code></p>

<p>And now you can see how autocompletion will work. Whenever a user types “v” in the search bar, we can return a list of search suggestions simply by returning the values in the “search-suggestions:v” set. There is no need for expensive queries that search through the entire database and look for matches. Instead, we find what we’re looking for right away. That&rsquo;s the beauty of Redis (and other key-value stores).</p>

<h2>Extracting Values from a Sorted Set</h2>

<p>But how do we extract values from a set? Well, Redis has a command called <a href="http://redis.io/commands/zrevrange"><code>ZREVRANGE</code></a> that does just that. It returns a range of elements sorted by score (with the highest scores listed first). Go ahead and add the following to <code>search_suggestion.rb</code>:</p>

<p>``` ruby search_suggestion.rb
&hellip;</p>

<p>  def self.terms_for(prefix)</p>

<pre><code>$redis.zrevrange 'search-suggestions:#{prefix.downcase}', 0, 9
</code></pre>

<p>  end</p>

<p>&hellip;
```</p>

<p>This function accepts a <code>prefix</code> variable and uses <code>ZREVRANGE</code> to return the first 10 elements of a sorted set containing the specified <code>prefix</code> value. We&rsquo;ll use it later to return a list of search suggestions to the user.</p>

<h1>Creating a Rake Task to Seed Redis</h1>

<p>In order to make it easy for us to seed Redis from the command line, we&rsquo;ll create a <a href="https://github.com/jimweirich/rake">Rake</a> task that calls the <code>seed()</code> method we defined earlier. (If you&rsquo;re new to Rake, I highly recommend watching the <a href="http://railscasts.com/episodes/66-custom-rake-tasks">Railscasts episode</a> about it.) Go ahead and create a new file called <code>search_suggestions.rake</code> inside your app&rsquo;s <code>/lib/tasks</code> directory, and add the following into it:</p>

<p>``` ruby search_suggestions.rake
namespace :search_suggestions do</p>

<p>  desc &lsquo;Generate search suggestions&rsquo;
  task index: :environment do</p>

<pre><code>SearchSuggestion.seed
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>The code is simple. We&rsquo;re creating a task called <code>index</code> and making it dependent on a Rake task provided by Rails called <code>environment</code>, which loads the Rails environment and gives us access to our <code>SearchSuggestion</code> class. Then we&rsquo;re just calling the <code>seed()</code> method we defined earlier to seed Redis. (We wrap this up inside a namespace called <code>search_suggestions</code> to keep things neat and organized.)</p>

<p>And now we can <code>cd</code> into our app&rsquo;s root directory and call this task from the command line, like so:</p>

<p><code>bash
rake search_suggestions:index
</code></p>

<p>You can then go into the Rails console with <code>rails c</code> and run some Redis commands to see if it worked. For example, if I defined a set called &ldquo;search-suggestions:v&rdquo; earlier, I can run the <code>ZREVRANGE</code> command to return the first 10 elements:</p>

<p><code>bash
$redis.zrange 'search-suggestions:v', 0, 9, with_scores: true
=&gt; [["vault martini", 1.0], ["via delizia", 1.0], ["vino bar", 1.0]]
</code></p>

<p>Note that if you want Redis to return the values along with their scores, you need to pass an argument called <code>with_scores</code> and set it to <code>true</code>; otherwise, Redis omits the scores.</p>

<h1>Setting Up the Front-End</h1>

<p>Now that we have the back-end functionality setup, it’s time to set up the front-end. We’ll use the jQueryUI <a href="http://api.jqueryui.com/autocomplete/">autocomplete widget</a> due to its simplicity and ease of use. We could include it in our app simply by adding the following to our <code>/app/assets/javascripts/application.js</code> file:</p>

<p><code>javascript application.js
//= require jquery-ui
</code></p>

<p>but this will include the entire library with all the widgets. I don’t like code bloat and prefer to include only the code that I actually need, so we&rsquo;ll take another route.</p>

<h2>Keeping Things Slim</h2>

<p>Head over to the jQueryUI <a href="http://jqueryui.com/download/">download page</a> and under “Components”, deselect the “Toggle All” option, which will deselect all the checkboxes. Then scroll down to the “Widgets” section, select “Autocomplete”, and you’ll see a few other necessary dependencies get selected automatically. Then press “Download”.</p>

<p>If you open the folder it downloaded and go into its <code>/js</code> directory, you’ll see a file that starts with “jquery-ui-” and ends with a “.custom.js” extension.  Open it and copy its code. Then head over to your app, create a new file called <code>autocomplete.js</code> inside the <code>/app/assets/javascripts</code> directory, and paste that code into it.</p>

<p>Now go back to the folder you just downloaded, go into its <code>/css</code> directory, find a file with a “.custom.css” extension, open it, and copy its code. Then create another file called <code>autocomplete.css</code> inside your app’s <code>/app/assets/stylesheets</code> directory and paste the code into it.</p>

<p>Now we have the code we need and no more.</p>

<h2>Hooking It up with HTML</h2>

<p>We&rsquo;re ready to connect the autocomplete code we just added to our app&rsquo;s HTML. In Phindee, I have a simple form with a search image and an input field that needs the autocomplete functionality:</p>

<p>``` erb
&hellip;</p>

<p><form class="search-form”>
  &lt;%= image_tag asset_path(&lsquo;search-icon.svg&rsquo;), class: &lsquo;search-icon&rsquo; %>
  <input type="text" class=“search-field" />
</form></p>

<p>&hellip;
```</p>

<p>In another file, I have the following CoffeeScript code that hooks up the autocomplete widget to the input field I just mentioned above:</p>

<p>``` coffeescript
&hellip;</p>

<p>  $(&lsquo;.search-field&rsquo;).autocomplete</p>

<pre><code>appendTo: '.search-form',
source: '/search_suggestions'
</code></pre>

<p>&hellip;
```</p>

<p>I’m simply calling the jQueryUI-provided <code>autocomplete()</code> method on the input field I&rsquo;m interested in. I then use the <code>appendTo</code> option to specify that the autocomplete drop-down should be appended to the form itself. Finally, I’m using <code>source</code> to specify the URL path the autocomplete widget will use to get a list of search suggestions that will be displayed in the drop-down. I chose a path called “/search_suggestions”, but you can choose any path you want.</p>

<h2>How It Works</h2>

<p>If you look at the <a href="http://api.jqueryui.com/autocomplete/#option-source">documentation</a> for <code>source</code>, you’ll see that it can accept the search suggestions as an array of strings, a string pointing to a URL that <em>returns</em> an array of strings, or a function with a response callback that also returns an array of strings. We’re using a string pointing to a URL since this fits our needs perfectly.</p>

<p>This is how it will work. The widget will take whatever is typed in the search field and append it to a variable called “term”, which itself will get appended to the URL path we specified in <code>source</code>. Then it’ll make a GET request to the URL and expect our server to respond with the search suggestions rendered as an array of strings in the JSON format. So for example, if the user types in “v”, the widget will make a GET request to “/search_suggestions?term=v”, and it’ll expect the server to respond with something like <code>["via delizia","vault martini”]</code>.</p>

<p>Our server doesn’t yet know how to respond to a URL like this. Let’s set it up.</p>

<h1>Creating a Controller to Handle Requests</h1>

<p>First, we’ll create a controller that takes the search phrase the user types in, passes it on to the <code>terms_for()</code> method we defined in <code>search_suggestion.rb</code>, and returns the resulting list of suggestions back to the user. We&rsquo;ll call it <code>search_suggestions</code>:</p>

<p><code>bash
rails g controller search_suggestions
</code></p>

<p>This will create a new file called <code>search_suggestions_controller.rb</code>. Open it and add the following code inside the <code>SearchSuggestionsController</code> class:</p>

<p>``` ruby search_suggestions_controller.rb
&hellip;</p>

<p>  def index</p>

<pre><code>render json: SearchSuggestion.terms_for(params[:term])
</code></pre>

<p>  end</p>

<p>&hellip;
```</p>

<p>We extract the value of the <code>term</code> variable using <code>params[:term]</code>, pass it on to the <code>terms_for()</code> method, and tell Rails to render the response in JSON format. Kid stuff.</p>

<p>Then open your app’s <code>/config/routes.rb</code> file and add the following line into it:</p>

<p>``` ruby routes.rb
&hellip;</p>

<p>  match &lsquo;/search_suggestions&rsquo;, to: &lsquo;search_suggestions#index&rsquo;, via: :get</p>

<p>&hellip;
```</p>

<p>This maps our <code>index</code> controller to the path we specified earlier in <code>source</code>, and our server now knows how to respond to a URL like &ldquo;/search_suggestions?term=v&rdquo;.</p>

<p>I think we’re ready for the moment of truth. Restart the rails server, type something in the search field, and if all is well with the world, you should see a drop-down menu with a list of search suggestions. If you don’t, you&rsquo;ll need to do some debugging to figure out what&rsquo;s wrong.</p>

<h1>Making It Work on a VPS</h1>

<p>Installing Redis on a VPS isn’t as easy as running <code>brew install redis</code>, but it’s not too bad. DigitalOcean has a <a href="https://www.digitalocean.com/community/articles/how-to-install-and-use-redis">nice tutorial</a> on the subject. I used it myself to get Redis installed on the server running Phindee, and it worked without a hiccup. I highly recommend it.</p>

<p>Once you have it installed, you’ll need to run the <code>index</code> task we wrote earlier to seed the database with data. If you’re using Capistrano, you can use the following task to run it from your local computer:</p>

<p>``` ruby
desc &lsquo;Seed the redis database (search suggestions)&rsquo;
task :seed_redis do
  on roles(:app) do</p>

<pre><code>within '#{current_path}' do
  with rails_env: :production do
    execute :rake, 'search_suggestions:index'
  end
end
</code></pre>

<p>  end
end
```</p>

<p>If you’re new to Capistrano, feel free to read through an <a href="/blog/2014/04/10/deploying-rails-apps-part-6-writing-capistrano-tasks/">earlier post</a> I wrote, which explains what it is and how you can use it. Or if you’re new to deployment in general, you’re welcome to go through my <a href="/blog/2014/03/05/deploying-rails-apps-part-1-securing-the-server/">6-part series</a>, which covers everything from setting up and securing a server to configuring Nginx, Unicorn, and Capistrano.</p>

<p>All right, that&rsquo;s all I have. Stay hungry. Stay foolish.</p>
]]></content>
  </entry>
  
</feed>
